#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string>
#include <iostream>
#include <fstream>
#include <string.h>
#include <limits.h>
#include <iomanip>

#include <vector>
#include <set>
#include <map>
#include <algorithm>

#include <iGeom.h>
#include <iMesh.h>
#include <iRel.h>

#include "SimpleArray.hpp"

#include "SearchUV.h"

map<int,int>  geomface;

int saveTetGen(const string &filename)
{

   // Read the mesh generated by OpenCascade OCCMeshGenerator and convert into
   // TetGen format which is supported by MOAB. 

   ofstream ofile;
   ifstream ifile( filename.c_str(), ios::in);
   if( ifile.fail() ) {
       cout << "Warning: Cann't open file " << filename << endl;
       return 1;
   }

   string str;
   ifile >> str;   assert( str == "mesh3d");

   ifile >> str;   assert( str == "dimension");

   int dimension;
   ifile >> dimension; assert( dimension == 3);
   
   ifile >> str;   assert( str == "geomtype");
   int geomtype;
   ifile >> geomtype;  assert( geomtype == 12);

   ifile >> str;
   char line[256];
   if( str[0] == '#') {
       ifile.getline( line, 256 );
   }

   ifile >> str; assert( str == "surfaceelementsuv");

   int numFaces;

   ifile >> numFaces;

   int surfnr, bcnr, domin, domout, np, vid;
   double u,v;

   ofile.open( "model.face", ios::out);
   ofile << numFaces <<  " 1 " <<  endl;

   for( int i = 0; i < numFaces; i++) 
   {
        ifile >> surfnr >> bcnr >> domin >> domout >> np;
        surfnr = surfnr - 1;  // Problem in NetGen, but developers not ready to modify.
        ofile << i << " ";
        for( int j = 0; j < np; j++) {
            ifile >> vid;
            ofile << vid - 1 << " ";
        }
        ofile << surfnr << endl;
        geomface[i] = surfnr;
      
        for( int j = 0; j < np; j++) 
             ifile >> u >> v;
   }
   ofile.close();

   ifile >> str;
   if( str[0] = '#') {
       ifile.getline( line, 256 );
   }
   ifile >> str; assert( str == "volumeelements");
   
   int numCells;
   ifile >> numCells;

   ofile.open( "model.ele", ios::out);
   ofile << numCells <<  " 4  1 " <<  endl;

   int matnr;
   for( int i = 0; i < numCells; i++) {
        ifile >> matnr >> np;
        ofile << i << " ";
        for( int j = 0; j < np; j++)  {
             ifile >> vid;
             ofile << vid-1 << " ";
        }
        ofile << matnr << endl;
   }
   ofile.close();

   ifile >> str;
   if( str[0] = '#') {
       ifile.getline( line, 256 );
   }
   ifile >> str; assert( str == "edgesegmentsgi2");

   int numEdges;
   ifile >> numEdges;

   int surfid, dummy , p1, p2, trignum1, trignum2, ednr1, ednr2;
   double dist1, dist2;

   ofile.open( "model.edge", ios::out);
   ofile << numEdges <<  endl;

   for( int i = 0; i < numEdges; i++) 
   {
        ifile >> surfid >> dummy >> p1 >> p2 >> trignum1 >> trignum2 >> domin >> domout 
              >> ednr1  >> dist1 >> ednr2 >> dist2;
        ofile << i << " " << p1-1 << " " << p2-1 << endl;
   }
   ofile.close();

   ifile >> str;
   if( str[0] = '#') ifile.getline( line, 256 );

   ifile >> str; assert( str == "points");

   int numNodes;
   ifile >> numNodes;

   double  x, y, z;
   ofile.open( "model.node", ios::out);
   ofile << numNodes <<  " 3  0  0 " <<  endl;

   for( int i = 0; i <  numNodes; i++) 
   {
        ifile >> x >> y >> z;
        ofile << i << " " << x << " " << y << " " << z << endl;
   }
   ofile.close();
}

///////////////////////////////////////////////////////////////////////////////

int readTetGen(iMesh_Instance &mesh)
{
   char  *options = NULL;
   int    optlen  = 0;
   int    err;
   iMesh_newMesh( options, &mesh, &err, optlen);  

   iBase_EntitySetHandle rootSet;
   iMesh_getRootSet( mesh, &rootSet, &err);

   const char *infile = "model.ele";
   int  namelen = strlen( infile );

   iMesh_load( mesh, rootSet, infile , options, &err, namelen, optlen);

  // Presently, the TetGen reader in MOAB created EntitySets, but doesn't
  // assign any Tag to the entitySet and it seems that the surfaceID ( attribute
  // on face in tetgen surface) are not stored. Therefore, we need to do
  // all these modification outside the reader.

  iBase_TagHandle  geom_id_tag, geom_dim_tag;
  const char *tag1 = "GEOM_ID";
  namelen  = strlen( tag1 );
  iMesh_createTag(mesh, tag1, 1, iBase_INTEGER, &geom_id_tag, &err, namelen );
  assert( !err );

  SimpleArray<iBase_EntityHandle> mFaceHandles;
  iMesh_getEntities(mesh, rootSet, iBase_FACE, iMesh_ALL_TOPOLOGIES,
                          ARRAY_INOUT(mFaceHandles), &err);
//assert( mFaceHandles.size() == geomface.size() );

  for( int i = 0; i < mFaceHandles.size(); i++) {
       int gid = geomface[i];
       iMesh_setIntData( mesh, mFaceHandles[i], geom_id_tag, gid, &err);
  }

/*
  const char *tag2 = "GEOM_DIMENSION";
  namelen  = strlen( tag2 );
  iMesh_getTagHandle(mesh, tag2,  &dim_tag, &err, namelen ); assert( !err );

  SimpleArray<iBase_EntitySetHandle>  entitySets;
  iMesh_getEntSets( mesh, rootSet, 0, ARRAY_INOUT(entitySets), &err);

  //
  // Assign Geometric face to each entitySet in mesh. In order to do that, get any
  // face in an entitySet, and assign the geometric face of the mesh face to the
  // entitySet. 
  //
  // One problem( or feature ) of the iMesh_getEntSets is that it returns 
  // parent entitySet also. It must be excluded for the classifications, therefore,
  // I have checked "entitySize == numFaces" to determine which one is parent
  // set.
  //
  int gid, faceid;
  SimpleArray<iBase_EntityHandle> facehandles;

  int numFaces;
  iMesh_getNumOfType( mesh, rootSet, iBase_FACE, &numFaces, &err);

  int ncount = 0;
  for( int i = 0; i < entitySets.size(); i++) {
       facehandles.clear();
       iMesh_getEntities( mesh, entitySets[i], iBase_FACE, iMesh_ALL_TOPOLOGIES,
                          ARRAY_INOUT(facehandles), &err);
       if( facehandles.size() && (facehandles.size() != numFaces )) 
       {
           ncount += facehandles.size();
           iMesh_getIntData( mesh, facehandles[0], id_tag, &gid, &err);
           faceid = geomface[gid]; // To which geometry face the mesh face belong.
           iMesh_setEntSetIntData( mesh, entitySets[i], id_tag,  faceid, &err);
           iMesh_setEntSetIntData( mesh, entitySets[i], dim_tag, 2, &err);
       }
  }
  assert( ncount == numFaces );
*/

  return 0;
}

//////////////////////////////////////////////////////////////////////////////

void verify_surface_mesh( iGeom_Instance &geom, iMesh_Instance &mesh)
{
  int err;
  int numFaces;
  int geom_face_id;

  iBase_TagHandle  geom_id_tag;

  const char *tag = "GLOBAL_ID";
  int namelen  = strlen( tag );

  iBase_EntitySetHandle gRootSet;
  iGeom_getRootSet( geom, &gRootSet, &err);

  SimpleArray<iBase_EntityHandle> gFaceHandles;
  iGeom_getEntities( geom, gRootSet, iBase_FACE, ARRAY_INOUT(gFaceHandles), &err);

  map<int, iBase_EntityHandle> geomFaceMap;
  numFaces = gFaceHandles.size();

  iGeom_getTagHandle(geom, tag, &geom_id_tag, &err, namelen );
  for(int i = 0; i < numFaces; i++) 
  {
      iGeom_getIntData( geom, gFaceHandles[i], geom_id_tag, &geom_face_id, &err);
      geomFaceMap[geom_face_id] = gFaceHandles[i];
  }

  iBase_EntitySetHandle mRootSet;
  iMesh_getRootSet( mesh, &mRootSet, &err);

  SimpleArray<iBase_EntityHandle> mFaceHandles;
  iMesh_getEntities(mesh, mRootSet, iBase_FACE, iMesh_ALL_TOPOLOGIES,
                          ARRAY_INOUT(mFaceHandles), &err);

  const char *tag1 = "GEOM_ID";
  namelen  = strlen( tag1 );
  iMesh_getTagHandle(mesh, tag1, &geom_id_tag, &err, namelen );
  assert( !err );

  double x0,y0,z0,x1,y1,z1,u,v;
  SimpleArray<iBase_EntityHandle> faceNodes;

  SearchUV searchUV;

  numFaces = mFaceHandles.size();
  double maxerror = 0.0;
  for(int i = 0; i < numFaces; i++) {
      if( i%100 == 0 ) cout << "Verified : " << i << endl;
      iMesh_getIntData( mesh, mFaceHandles[i], geom_id_tag, &geom_face_id, &err);
      assert( !err );
      iBase_EntityHandle gFace = geomFaceMap[geom_face_id];
      faceNodes.clear();
      iMesh_getEntAdj( mesh, mFaceHandles[i], iBase_VERTEX, ARRAY_INOUT(faceNodes), &err);
      for( int j = 0; j < faceNodes.size(); j++) {
           iMesh_getVtxCoord( mesh, faceNodes[j], &x0, &y0, &z0, &err);
           searchUV.getUV( geom, gFace, x0, y0, z0, u, v);
           iGeom_getEntUVtoXYZ( geom, gFace, u, v, &x1, &y1, &z1, &err);
           double dx = x1-x0;
           double dy = y1-y0;
           double dz = z1-z0;
           maxerror  = max( maxerror, dx*dx+ dy*dy + dz*dz);
       }
   }
   cout << " Maximum Error in the model " << sqrt(maxerror) << endl;
}

//////////////////////////////////////////////////////////////////////////////

void readMesh( const string &filename, iMesh_Instance &mesh)
{
    saveTetGen( filename );
    readTetGen( mesh );
}

//////////////////////////////////////////////////////////////////////////////

int readGeometry(const string &filename, iGeom_Instance &geom)
{
    string engine_opt = ";engine=OCC";

    int err;
    iGeom_newGeom(engine_opt.c_str(), &geom, &err, engine_opt.length());
    iGeom_load(geom, &filename[0], 0, &err, filename.length(), 0);

    iBase_EntitySetHandle rootSet;
    iGeom_getRootSet(geom, &rootSet, &err);

    cout << "Model Contents " << endl;
    const char *gtype[] = {"vertices: ", "edges: ", "faces: ", "regions: "};

    int count;
    for (int i = 0; i <= 3; ++i)
    {
        iGeom_getNumOfType(geom, rootSet, i, &count, &err);
        std::cout << gtype[i] << count << std::endl;
    }
}
//////////////////////////////////////////////////////////////////////////////

int main( int argc, char **argv)
{
  int err;
  if( argc != 3 ) {
      cout << " Usage: executable unvfile vtkfile " << endl;
      return 1;
  }
/*
  iGeom_Instance geom;
  readGeometry( argv[1], geom);
*/
  
  iMesh_Instance mesh;
  readMesh( argv[1], mesh);

  cout << " ehll : " << endl;

//verify_surface_mesh( geom, mesh);

  iBase_EntitySetHandle rootSet;
  iMesh_getRootSet( mesh, &rootSet, &err);
 
  const char *outfile = argv[2];
  int namelen = strlen( outfile );
  char  *options = NULL;
  int    optlen  = 0;
  iMesh_save( mesh, rootSet, outfile , options, &err, namelen, optlen);
}

